/*

PROJECT WRITE-UP

I will walk through each rubric point and briefly describe how I met the requirement.
Requirement
- Description


Compilation

The code compiles correctly.
- In the directory "CarND-Path-Planning-Project/src/build", entering "make" into the terminal builds the code without error.
    
 
Valid Trajectories

The car is able to drive at least 4.32 miles without incident.
- As seen in the simulation, the car drives farther than 4.32 miles without incident.

The car drives according to the speed limit.
- Lines 214-231 of main.cpp detail how the speed limit is kept. If the vehicle is obstructed and neither of the other lanes is available, then the speed is decreased by 0.5 mph. If the vehicle is not obstructed and the current speed is less than 49.5 mph, then the speed is increased by 0.25 mph. This ensures that the speed never exceeds 50 mph.      

Max Acceleration and Jerk are not Exceeded.
- The car does not exceed a total acceleration of 10 m/s^2 and a jerk of 10 m/s^3. This was ensured on a trial-and-error basis. To limit the tangential acceleration, the speed is increased by only 0.25 mph each cycle. Also a spline with widely-spaced points (5 points evenly spaced by 30m) is used to limit the amount of normal acceleration when switching lanes. This is performed in lines 277-310 of main.cpp. The spline is created using functions from header file spline.h. 

Car does not have collisions.
- The car does not come in contact with other vehicles. To avoid other vehicles, the program follows a logical algorithm detailed in lines 129-231 of main.cpp. If another vehicle is detected in front of the ego car and the gap violates the 2 second rule**, the program scans the left lane for an adequate rear and front gap. If the gap is big enough, the ego car switches to the left lane. If the left lane is occupied or the ego car is in the leftmost lane, the lane to the right is scanned for an adequate gap. If the gap is big enough, the ego car switches to the right lane. If the right lane is also occupied or we are in the rightmost lane, the ego car deccelerates and repeats the algorithm. 
** The 2 second rule is a rule of thumb for following distance. You should keep a 2 second gap between yourself and the vehicle you are following. 

The car stays in its lane, except for the time between changing lanes.
- The car doesn't spend more than a 3 second length out side the lane lanes during changing lanes, and every other time the car stays inside one of the 3 lanes on the right hand side of the road. The variable "lane" is introduced in line 55 of main.cpp. When switching lanes, the program's logic makes it only possible to switch between lanes 0, 1, and 2 (left, center, and right). The splines used for trajectory planning are not slow enough to cause the car to remain between two lanes for an extended period. 

The car is able to change lanes.
- The car is able to smoothly change lanes when it makes sense to do so, such as when behind a slower moving car and an adjacent lane is clear of other traffic. As described in the rubric point "Car does not have collisions", the car tries to change lanes when another vehicle is in the way. The splines's points are spaced widely enough to avoid a jerky lane change.  


Reflection

There is a reflection on how to generate paths.
- The path generation process is lines 234-349 of main.cpp. First, vectors ptsx and ptsy are defined as waypoints for the car's intended trajectory; if the previous path (defined in lines 89-91) is almost empty, then the reference point for the new path is the car itself. Otherwise, the reference point is the last point of the previous path. Then, five evenly spaced by 30m points are selected in front of the vehicle to create a spline of the desired path. The GetXY function is used to convert frenet coordinates and map data to xy coordinates. All of these points are then converted to the vehicle's reference frame to simplify further calculations. Using spline.h's set_points function, a spline of the desired path is generated. To ensure legal speed is kept along the spline, the variable target_dist is introduced as the vector sum of target_x (30m) and target_y (corresponding y value for x = 30). The path planner is then filled by looping through 50 points. A variable N is calculated as N = target_dist / ( 0.02 * ref_vel ) * 2.24. 0.02 refers to the number of seconds per update, ref_vel is a variable for desired speed, and 2.24 is the conversion from mph to m/s. To select each of the 50 points, a linear approximation of the spline is used by assuming each point to be spaced evenly apart. The points are generated by x = target_x/N then y = spline(x). The xy points are then rotated back to normal out of the car's frame. Those points are added to the reference points and sent to the car via json message. 

*/
